CREATE TABLE dnr_daily_weather (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    meas_date DATE NOT NULL,
    yr INTEGER GENERATED ALWAYS AS (date_part('YEAR', meas_date)::INTEGER) STORED,
    mnth INTEGER GENERATED ALWAYS AS (date_part('MONTH', meas_date)::INTEGER) STORED,
    dy INTEGER GENERATED ALWAYS AS (date_part('DAY', meas_date)::INTEGER) STORED,
    season VARCHAR(6) GENERATED ALWAYS AS (
        CASE
          WHEN date_part('MONTH', meas_date)::INTEGER BETWEEN 3 AND 5 THEN 'Spring'
          WHEN date_part('MONTH', meas_date)::INTEGER BETWEEN 6 AND 8 THEN 'Summer'
          WHEN date_part('MONTH', meas_date)::INTEGER BETWEEN 9 AND 11 THEN 'Fall'
          ELSE 'Winter'
        END) STORED,
    max_temp DOUBLE PRECISION,
    min_temp DOUBLE PRECISION,
    precip DOUBLE PRECISION,
    snowfall DOUBLE PRECISION
);

CREATE INDEX meas_date_index ON dnr_daily_weather(meas_date);
CREATE INDEX max_temp_index ON dnr_daily_weather(max_temp);
CREATE INDEX min_temp_index ON dnr_daily_weather(min_temp);
CREATE INDEX precip_index ON dnr_daily_weather(precip);
CREATE INDEX snowfall_index ON dnr_daily_weather(snowfall);

CREATE VIEW seasons_data AS
SELECT
  tb.season_yr AS yr,
  tb.season,
  sum(tb.precip) AS total_precip
FROM (
  SELECT
    CASE
        WHEN dnr_daily_weather.season = 'Winter' AND dnr_daily_weather.mnth < 12
        THEN dnr_daily_weather.yr - 1
        ELSE dnr_daily_weather.yr
    END AS season_yr,
    dnr_daily_weather.season,
    dnr_daily_weather.precip
  FROM dnr_daily_weather
  WHERE dnr_daily_weather.meas_date BETWEEN '1890-03-01' AND '2019-11-30'
) tb
GROUP BY tb.season_yr, tb.season;
